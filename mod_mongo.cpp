/*
**  mod_mongo.c -- Apache sample mongo module
**  [Autogenerated via ``apxs -n mongo -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory
**  by running:
**
**    $ apxs -c -i mod_mongo.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /mongo in as follows:
**
**    #   httpd.conf
**    LoadModule mongo_module modules/mod_mongo.so
**    <Location /mongo>
**    SetHandler mongo
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /mongo and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/mongo
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**
**    The sample page from mod_mongo.c
*/

//httpd-devel
//apr-devel
//libapreq2-devel
//libmongoclient

/* mongo */
#include "mongo/client/dbclient.h"
#include "mongo/client/connpool.h"

/* httpd */
#ifdef __cplusplus
extern "C" {
#endif
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_main.h"
#include "util_script.h"
#include "ap_config.h"
#include "apr_reslist.h"
#include "apr_strings.h"
#include "apreq2/apreq_module_apache2.h"
#ifdef __cplusplus
}
#endif

//DEBUG:log
#include "http_log.h"
#define _ERR(rec, format, args...) \
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, \
                  rec, "%s(%d) "format, __FILE__, __LINE__, ##args);
#if 1
#define _DEBUG(rec, format, args...)
#else
#define _DEBUG(rec, format, args...)         \
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0,                        \
                  rec, "%s(%d) "format, __FILE__, __LINE__, ##args);
#endif

#define ISINT(val) \
    const char * p; \
    for (p = val; *p; ++p)  if (!isdigit(*p)) return "Argument must be numeric!"

/* モジュール設定情報(追加) */
/*
typedef struct {
    char* server;
    char* ns;
    int timeout;
    bool scoped;
} mongo_config_t;
*/
typedef struct {
    //mongo::ScopedDbConnection* conn;
    //mongo::DBClientConnection* cli;
    char* server;
    char* ns;
    int timeout;

    apr_reslist_t* connpool;
    int min;
    int keep;
    int max;
    int exptime;

} mongo_config_t;

/* 設定情報読み込み(追加) */
static const char* mongo_set_server(cmd_parms* parms, void* config, char* val);
static const char* mongo_set_ns(cmd_parms* parms, void* config, char* val);
static const char* mongo_set_timeout(cmd_parms* parms, void* config, char* val);
static const char* mongo_set_min(cmd_parms* parms, void* config, char* val);
static const char* mongo_set_keep(cmd_parms* parms, void* config, char* val);
static const char* mongo_set_max(cmd_parms* parms, void* config, char* val);
static const char* mongo_set_exptime(cmd_parms* parms, void* config, char* val);

/* 設定情報の生成・初期化(追加) */
/*
static void* mongo_create_dir_config(apr_pool_t* pool, char* arg) {
    mongo_config_t* cfg =
        (mongo_config_t*)apr_pcalloc(pool, sizeof(mongo_config_t));

    // default value
    cfg->server = "localhost";
    cfg->ns = "test.test";
    cfg->timeout = 0;
    //cfg->scoped = FALSE;

    return (void *)cfg;
}
*/

static void *mongo_server_config(apr_pool_t *p, server_rec *s) {
    mongo_config_t* cfg =
        (mongo_config_t*)apr_pcalloc(p, sizeof(mongo_config_t));

    cfg->server = "localhost";
    cfg->ns = "test.test";
    cfg->timeout = 0;
    cfg->max = 1;
    cfg->min = 1;
    cfg->keep = 1;
    cfg->exptime = 30;

    return (void*)cfg;
}

/* 設定情報フック定義(追加) */
#define CMD_SET(func) reinterpret_cast<const char*(*)()>(mongo_set_ ## func)
static const command_rec mongo_cmds[] = {
    AP_INIT_TAKE1(
        "MongoServer", CMD_SET(server), NULL,
        ACCESS_CONF|RSRC_CONF, "mongoDB server."),
    AP_INIT_TAKE1(
        "MongoNamespace", CMD_SET(ns), NULL,
        ACCESS_CONF|RSRC_CONF, "mongoDB db and collection."),
    AP_INIT_TAKE1(
        "MongoTimeout", CMD_SET(timeout), NULL,
        ACCESS_CONF|RSRC_CONF, "mongoDB connection timeout."),
    AP_INIT_TAKE1(
        "MongoPoolMin", CMD_SET(min), NULL,
        ACCESS_CONF|RSRC_CONF, "Minimum number of connections"),
    AP_INIT_TAKE1(
        "MongoPoolKeep", CMD_SET(keep), NULL,
        ACCESS_CONF|RSRC_CONF, "Maximum number of sustained connections"),
    AP_INIT_TAKE1(
        "MongoPoolMax", CMD_SET(max), NULL,
        ACCESS_CONF|RSRC_CONF, "Maximum number of connections"),
    AP_INIT_TAKE1(
        "MongoPoolExptime", CMD_SET(exptime), NULL,
        ACCESS_CONF|RSRC_CONF, "Keepalive time for idle connections"),
    { NULL, NULL, NULL, 0, TAKE1, NULL }
};

/* 関数宣言 */
static int mongo_post_config(
    apr_pool_t* p, apr_pool_t* plog, apr_pool_t* ptemp, server_rec* s);
static int mongo_handler(request_rec* r);

static void mongo_register_hooks(apr_pool_t* p) {
    ap_hook_post_config(mongo_post_config, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_handler(mongo_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

#ifdef __cplusplus
extern "C" {
#endif
module AP_MODULE_DECLARE_DATA mongo_module = {
    STANDARD20_MODULE_STUFF,
    NULL,                    /* create per-dir    config structures */
    NULL,                    /* merge  per-dir    config structures */
    mongo_server_config,     /* create per-server config structures */
    NULL,                    /* merge  per-server config structures */
    mongo_cmds,              /* table of config file commands       */
    mongo_register_hooks     /* register hooks                      */
};
#ifdef __cplusplus
}
#endif

/* 設定情報読み込み(追加) */
static const char* mongo_set_server(cmd_parms* parms, void* config, char* val) {
    mongo_config_t* cfg =
        (mongo_config_t*)ap_get_module_config(
            parms->server->module_config, &mongo_module);
    //mongo_config_t* cfg = (mongo_config_t*)config;
    cfg->server = apr_pstrdup(parms->pool, val);
    return NULL;
}

static const char* mongo_set_ns(cmd_parms* parms, void* config, char* val) {
    mongo_config_t* cfg =
        (mongo_config_t*)ap_get_module_config(
            parms->server->module_config, &mongo_module);
    //mongo_config_t* cfg = (mongo_config_t*)config;
    cfg->ns = apr_pstrdup(parms->pool, val);
    return NULL;
}

static const char* mongo_set_timeout(cmd_parms* parms, void* config, char* val) {
    mongo_config_t* cfg =
        (mongo_config_t*)ap_get_module_config(
            parms->server->module_config, &mongo_module);
    //mongo_config_t* cfg = (mongo_config_t*)config;
    //ISINT(val);
    int timeout = atoi(val);
    if (timeout >= 0) {
        cfg->timeout = timeout;
    }
    return NULL;
}

/*
static const char* mongo_set_scoped(cmd_parms* parms, void* config, char* arg) {
    mongo_config_t* cfg = (mongo_config_t*)config;
    if (arg) {
        cfg->scoped = TRUE;
    }
    return NULL;
}
*/

static const char* mongo_set_min(cmd_parms* parms, void* config, char* val) {
    mongo_config_t* cfg =
        (mongo_config_t*)ap_get_module_config(
            parms->server->module_config, &mongo_module);
    //mongo_config_t* cfg = (mongo_config_t*)config;
    //ISINT(val);
    cfg->min = atoi(val);
    return NULL;
}

static const char* mongo_set_keep(cmd_parms* parms, void* config, char* val) {
    mongo_config_t* cfg =
        (mongo_config_t*)ap_get_module_config(
            parms->server->module_config, &mongo_module);
    //mongo_config_t* cfg = (mongo_config_t*)config;
    //ISINT(val);
    cfg->keep = atoi(val);
    return NULL;
}

static const char* mongo_set_max(cmd_parms* parms, void* config, char* val) {
    mongo_config_t* cfg =
        (mongo_config_t*)ap_get_module_config(
            parms->server->module_config, &mongo_module);
    //mongo_config_t* cfg = (mongo_config_t*)config;
    //ISINT(val);
    cfg->max = atoi(val);
    return NULL;
}

static const char* mongo_set_exptime(cmd_parms* parms, void* config, char* val) {
    mongo_config_t* cfg =
        (mongo_config_t*)ap_get_module_config(
            parms->server->module_config, &mongo_module);
    //mongo_config_t* cfg = (mongo_config_t*)config;
    //ISINT(val);
    cfg->exptime = atoi(val);
    return NULL;
}

typedef struct {
    bool active;
    bool rows;
    char* jsonp;
    request_rec* rec;
    mongo::BSONObjBuilder bson;
} mongo_query_t;

static int mongo_query_iterate(void* req, const char* key, const char* value) {
    if (key == NULL || value == NULL || value[0] == '\0') {
        return TRUE;
    }

    mongo_query_t* query = (mongo_query_t*)req;
    _DEBUG(query->rec, "[debug]:%s => %s", key, value);

    //クエリー
    //?key=###(&rows=1&jsonp=###)&data.1=###&data.2=###

    //未実装
    // filter=
    // limit=
    // skip=

    if (strcmp(key, "key") == 0) {
        query->active = TRUE;
        try {
            query->bson.append("key", value);
        } catch(mongo::MsgAssertionException &e) {
            _ERR(query->rec, "mongo.append: %s", e.what());
        }
    } else if (strncmp(key, "data.", 5) == 0) {
        char* data = apr_psprintf(query->rec->pool, "%s", key);
        try {
            query->bson.append(data, value);
        } catch(mongo::MsgAssertionException &e) {
            _ERR(query->rec, "mongo.append: %s", e.what());
        }
    } else if (strcmp(key, "rows") == 0) {
        query->rows = TRUE;
    } else if (strcmp(key, "jsonp") == 0) {
        query->jsonp = apr_psprintf(query->rec->pool, "%s", value);
    }

    return TRUE;
}

static apr_status_t mongo_construct(void** cli, void* params, apr_pool_t* pool) {
    mongo_config_t* cfg = (mongo_config_t*)params;

    try {
        *cli = new mongo::DBClientConnection(true, 0, cfg->timeout);
        ((mongo::DBClientConnection*)(*cli))->connect(cfg->server);
    } catch(mongo::DBException &e) {
        ap_log_perror(
            APLOG_MARK, APLOG_CRIT, 0, pool,
            "mongo.server: %s: %s", cfg->server, e.what()) ;
        return APR_EGENERAL ;
    }

    return APR_SUCCESS ;
}

static apr_status_t mongo_destruct(void* cli, void* params, apr_pool_t* pool) {
    delete (mongo::DBClientConnection*)cli;
    return APR_SUCCESS ;
}

/* post config */
static int mongo_post_config(
    apr_pool_t* p, apr_pool_t* plog, apr_pool_t* ptemp, server_rec* s) {

    mongo_config_t* cfg = (mongo_config_t*)
        ap_get_module_config(s->module_config, &mongo_module) ;

    if (apr_reslist_create(
            &cfg->connpool, cfg->min, cfg->keep, cfg->max, cfg->exptime,
            mongo_construct, mongo_destruct,
            cfg, p) != APR_SUCCESS ) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, "failed to initialise");
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    apr_pool_cleanup_register(
        p, cfg->connpool, (apr_status_t(*)(void *))apr_reslist_destroy, apr_pool_cleanup_null);

    return OK ;
}

/* content handler */
static int mongo_handler(request_rec* r) {
    if (strcmp(r->handler, "mongo")) {
        return DECLINED;
    }

    /* 設定情報取得(追加) */
    /*
    mongo_config_t* cfg =
        (mongo_config_t*)ap_get_module_config(r->per_dir_config, &mongo_module);

    _DEBUG(r, "[server]:%s", cfg->server);
    _DEBUG(r, "[ns] %s", cfg->ns);
    _DEBUG(r, "[timeout] %d", cfg->timeout);
    _DEBUG(r, "[scoped] %d", cfg->scoped);
    */

    /* content type */
    r->content_type = "application/json; charset=utf-8";

    /*
    ap_rprintf(r,"method = %s\n",r->method);
    ap_rprintf(r,"uri = %s\n",r->uri);
    ap_rprintf(r,"filename = %s\n",r->filename);
    ap_rprintf(r,"user-agent = %s\n",apr_table_get(r->headers_in, "User-Agent"));
    */
    /*
    apr_table_set(r->headers_out, "Set-Cookie","visited=true;");
    cookie = apr_table_get(r->headers_in, "Cookie");
    if(cookie!=NULL && strcmp(cookie, "visited=true")==0) {
        return HTTP_FORBIDDEN;
    }
    */

    if (!r->header_only) {
        /* query */
        //const char* query;
        //const char* api;
        //query = apr_table_get(r->subprocess_env, "QUERY_STRING");
        //api = get_value(r, query, "_api");
        //char *val = apr_table_get(tbl, key);
        /*
        apreq_handle_t *apreq;
        //const apreq_param_t *api;
        apreq = apreq_handle_apache2(r);
        */
        /*
        api = apreq_param(apreq, "api");
        if (api)
        {
            _DEBUG(r, "[api]:%s", api->v.data);
        }
        */
        //(apr_table_t *)apreq_params(apreq_handle_t *req, apr_pool_t *p);
        //char *bbs, *key, *time, *from, *mail, *message, *pon;
        //apreq_handle_t *apreq_handle;
        //apr_table_t *params, *cookies;
        //apreq_param_t *file;
        /*
        apr_table_t *params;
        params = apreq_params(apreq, r->pool);
        apr_table_do(iterate_params, r, params, NULL);
        */

        /*
        cookies = apreq_cookies(apreq_handle, r->pool);

        bbs = apr_table_get(params, "bbs");
        key = apr_table_get(params, "key");
        time = apr_table_get(params, "time");
        from = apr_table_get(params, "FROM");
        mail = apr_table_get(params, "mail");
        message = apr_table_get(params, "MESSAGE");
        pon = apr_table_get(cookies, "PON");
        */

        /* mongo */
        mongo::DBClientConnection* cli = NULL;
        mongo_config_t* cfg = (mongo_config_t*)
            ap_get_module_config(r->server->module_config, &mongo_module);

        _DEBUG(r, "[server]:%s", cfg->server);
        _DEBUG(r, "[ns] %s", cfg->ns);
        _DEBUG(r, "[min] %d", cfg->min);
        _DEBUG(r, "[max] %d", cfg->max);
        _DEBUG(r, "[keep] %d", cfg->keep);

        if (apr_reslist_acquire(cfg->connpool, (void**)&cli) != APR_SUCCESS ) {
            _ERR(r, "Failed to acquire mongoDB connection from pool!") ;
            return DECLINED;
        }

        /*
        mongo::DBClientConnection* cli;

        try {
            if (cfg->scoped) {
                mongo::ScopedDbConnection conn(cfg->server, cfg->timeout);
                cli = dynamic_cast<mongo::DBClientConnection*>(&conn.conn());
                conn.done();
            } else {
                cli = new mongo::DBClientConnection(true, 0, cfg->timeout);
                cli->connect(cfg->server);
            }
        } catch(mongo::DBException &e) {
            _ERR(r, "mongo.server: %s: %s", cfg->server, e.what());
            delete cli;
            return DECLINED;
        }
        */

        //読み込み
        mongo_query_t query;
        query.rec = r;
        query.active = FALSE;
        query.rows = FALSE;
        query.jsonp = NULL;

        apreq_handle_t* apreq = apreq_handle_apache2(r);
        apr_table_t* params = apreq_params(apreq, r->pool);
        if (params) {
            apr_table_do(mongo_query_iterate, &query, params, NULL);
        }

        if (query.active) {
            try {
                if (query.rows) {
                    //すべてのクエリ
                    mongo::BSONArray arr;
                    mongo::BSONArrayBuilder bson;
                    std::auto_ptr<mongo::DBClientCursor> cursor =
                        cli->query(cfg->ns, query.bson.obj());
                    while (cursor->more()) {
                        mongo::BSONObj row = cursor->next();
                        if (!row.isEmpty()) {
                            //data フィールドを取得
                            mongo::BSONObj data = row.getObjectField("data");
                            if (!data.isEmpty()) {
                                bson.append(data);
                            }
                        }
                    }
                    arr = bson.arr();
                    //出力
                    if (query.jsonp != NULL) {
                        ap_rprintf(r, "%s(", query.jsonp);
                        ap_rprintf(r, "%s", arr.toString(1).c_str());
                        ap_rprintf(r, ")");
                    } else {
                        ap_rprintf(r, "%s", arr.toString(1).c_str());
                    }
                } else {
                    //単一クエリ: findOne
                    mongo::BSONObj obj;
                    mongo::BSONObj bson = cli->findOne(
                        cfg->ns, query.bson.obj());
                    //data フィールドを取得
                    obj = bson.getObjectField("data");
                    //出力
                    if (query.jsonp != NULL) {
                        ap_rprintf(r, "%s(", query.jsonp);
                        ap_rprintf(r, "%s", obj.toString().c_str());
                        ap_rprintf(r, ")");
                    } else {
                        ap_rprintf(r, "%s", obj.toString().c_str());
                    }
                }
            } catch(mongo::MsgAssertionException &e) {
                _ERR(r, "mongo: %s", e.what());
                //delete cli;
                return DECLINED;
            }
        }

        //delete cli;
    }

    return OK;
}



/*
TODO: unicode escape
TODO: deflate GZIP compress

TODO: mongo::ScopedDbConnection は Segmentation fault が発生する

namespace mongo;

inline void BSONObj::toString(StringBuilder& s,  bool isArray, bool full ) const {
    if ( isEmpty() ) {
        s << "{}";
        return;
    }

    s << ( isArray ? "[ " : "{ " );
    BSONObjIterator i(*this);
    bool first = true;
    while ( 1 ) {
        massert( 10327 ,  "Object does not end with EOO", i.moreWithEOO() );
        BSONElement e = i.next( true );
        massert( 10328 ,  "Invalid element size", e.size() > 0 );
        massert( 10329 ,  "Element too large", e.size() < ( 1 << 30 ) );
        int offset = (int) (e.rawdata() - this->objdata());
        massert( 10330 ,  "Element extends past end of object",
                 e.size() + offset <= this->objsize() );
        e.validate();
        bool end = ( e.size() + offset == this->objsize() );
        if ( e.eoo() ) {
            massert( 10331 ,  "EOO Before end of object", end );
            break;
        }
        if ( first )
            first = false;
        else
            s << ", ";
        e.toString(s, !isArray, full );
    }
    s << ( isArray ? " ]" : " }" );
}

inline void BSONElement::toString(StringBuilder& s, bool includeFieldName, bool full ) const {
    if ( includeFieldName && type() != EOO )
        s << fieldName() << ": ";
    switch ( type() ) {
        case EOO:
            s << "EOO";
            break;
        case mongo::Date:
            s << "new Date(" << (long long) date() << ')';
            break;
        case RegEx: {
            s << "/" << regex() << '/';
            const char *p = regexFlags();
            if ( p ) s << p;
        }
            break;
        case NumberDouble:
            s.appendDoubleNice( number() );
            break;
        case NumberLong:
            s << _numberLong();
            break;
        case NumberInt:
            s << _numberInt();
            break;
        case mongo::Bool:
            s << ( boolean() ? "true" : "false" );
            break;
        case Object:
            embeddedObject().toString(s, false, full);
            break;
        case mongo::Array:
            embeddedObject().toString(s, true, full);
            break;
        case Undefined:
            s << "undefined";
            break;
        case jstNULL:
            s << "null";
            break;
        case MaxKey:
            s << "MaxKey";
            break;
        case MinKey:
            s << "MinKey";
            break;
        case CodeWScope:
            s << "CodeWScope( "
              << codeWScopeCode() << ", " << codeWScopeObject().toString(false, full) << ")";
            break;
        case Code:
            if ( !full &&  valuestrsize() > 80 ) {
                s.write(valuestr(), 70);
                s << "...";
            }
            else {
                s.write(valuestr(), valuestrsize()-1);
            }
            break;
        case Symbol:
        case mongo::String:
            s << '"';
            if ( !full &&  valuestrsize() > 160 ) {
                s.write(valuestr(), 150);
                s << "...\"";
            }
            else {
                s.write(valuestr(), valuestrsize()-1);
                s << '"';
            }
            break;
        case DBRef:
            s << "DBRef('" << valuestr() << "',";
            {
                mongo::OID *x = (mongo::OID *) (valuestr() + valuestrsize());
                s << *x << ')';
            }
            break;
        case jstOID:
            s << "ObjectId('";
            s << __oid() << "')";
            break;
        case BinData:
            s << "BinData";
            if (full) {
                int len;
                const char* data = binDataClean(len);
                s << '(' << binDataType() << ", " << toHex(data, len) << ')';
            }
            break;
        case Timestamp:
            s << "Timestamp " << timestampTime() << "|" << timestampInc();
            break;
        default:
            s << "?type=" << type();
            break;
    }
}
*/
